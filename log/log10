https://bypass.churchless.tech/
ask for answer(press Enter twice to finish): 

生成一道编程题，涉及以下内容：
[算法]
大根堆、KMP
[代码量]
完成题目所需要编写的代码量在 60 行左右
[难度]
困难，题干在理解的逻辑难度上，一定要保证题目描述不能被一眼看出解法及考点，解法需要 15 分钟以上的思考
[语言]
Python，C++
[场景]
金融交易
[核心]
- 不要抄袭 LeetCode 等主流算法刷题平台的内容，生成的题目是原创的，具有挑战的
- 具体详尽的业务场景和需求约束条件

题目名称：金融交易引擎的优化

题目描述：
你是一家金融公司的技术主管，你需要设计并实现一个优化的金融交易引擎。为了提高效率，你计划将市场交易订单在内存中进行组织和存储。 

你的交易引擎会面临大量的订单输入，并需要保证在最短时间内找到最优交易订单。这些交易订单包括价格和一个唯一的交易订单标识。最优交易订单是指价格最高的交易订单。 

为了实现这个目标，你决定使用大根堆数据结构，它能在O(1)时间内找到最优交易订单，并且在O(logN)时间内进行插入和删除。

然而，公司内部已经存在一个老旧的交易引擎，其使用了一种特殊的命令序列，即由许多"sell", "buy" 和"cancel"构成的字符串来处理交易。每个"sell", "buy"是一个新订单的指示，后面紧跟订单价格，而"cancel"后面跟的是订单标识，表示取消之前的交易订单。每个指令之间以逗号隔开。

为了兼容老旧引擎，你需要使用KMP算法解析这个命令序列，然后在你的新交易引擎中执行相应的操作。

请你实现一个类 TradeEngine，包含以下方法：

- __init__(): 初始化你的交易引擎
- addOrder(orderID: str, price: int): 增加一个交易订单
- removeOrder(orderID: str): 移除一个交易订单
- getBestOrder(): 获取当前价格最高的交易订单，如果没有订单则返回None
- parseAndExecute(commands: str): 使用KMP算法解析输入的命令字符串，并执行相应的交易操作。命令字符串的格式为："buy 1000, sell 2000, cancel order123"

你需要确保每个命令都在最优的时间复杂度下完成。

提示：大根堆在Python中可以使用`heapq`库实现，在C++中可以使用`priority_queue`实现；KMP算法主要用于字符串的模式匹配，本题需要对其稍作修改以适应解析命令的需求。

约束：
- orderID 是一个非空的字符串，长度不超过 10^6，只包含数字和字母，保证是唯一的。
- price 是一个非负整数，不超过 10^9。
- 每个交易指令的数量不超过 10^6。
- 所有交易指令的总长度不超过 10^6。
- 确保 addOrder 和 removeOrder 能在堆中快速定位到订单，可能需要用到额外的数据结构存储订单的位置。
- 使用Python或
ask for answer(press Enter twice to finish): 
