https://bypass.churchless.tech/
ask for answer(press Enter twice to finish): 
https://bypass.churchless.tech/
ask for answer(press Enter twice to finish): 

生成一道编程题，涉及以下内容：
[算法]
矩阵、二叉搜索树、DFS
[代码量]
完成题目所需要编写的代码量在 60 行左右
[难度]
困难，题干在理解的逻辑难度上，一定要保证题目描述不能被一眼看出解法及考点，解法需要 15 分钟以上的思考
[语言]
Python，C++
[场景]
金融交易
[核心]
- 不要抄袭 LeetCode 等主流算法刷题平台的内容，生成的题目是原创的，具有挑战的
- 具体详尽的业务场景和需求约束条件


**题目：交易记录的异常检测**

在金融交易系统中，每笔交易都会记录下来，形成一个交易记录矩阵。每一行代表一笔交易，每一列代表一个特征（如交易金额、交易类型、交易发起方等）。我们希望检测出可能存在问题的交易记录。

我们将问题定义为：一笔交易记录与其他交易记录的某一特征差异过大。差异过大的定义为：某一特征的值在所有交易记录中构成的二叉搜索树（BST）中的深度大于平均深度的两倍。

你需要完成以下任务：

1. 定义一个二叉搜索树（BST）的数据结构，并实现插入、查找和计算平均深度的功能。

2. 实现一个函数，将交易记录矩阵转化为BST，每一列对应一个BST。

3. 实现一个深度优先搜索（DFS）算法，对每一个BST进行深度搜索，找出深度大于平均深度的两倍的节点。

4. 基于以上步骤，编写一个函数，输入为交易记录矩阵，输出为所有可能存在问题的交易记录。

**限制条件**：

1. 交易记录矩阵的每一列都是整数。
2. 交易记录矩阵的大小在 10^3 x 10^3 以下。
3. 你可以假设交易记录矩阵的每一列都没有重复的元素。

注意：题目的难点在于如何高效地计算BST的平均深度，如何将DFS和BST结合来找出深度过大的节点，以及如何处理大量的交易记录数据。请使用Python或C++完成你的答案。

**输入格式**：

输入是一个二维列表，代表交易记录矩阵。

**输出格式**：

输出是一个二维列表，代表所有可能存在问题的交易记录。每一行应当是一个列表，代表一笔可能存在问题的交易记录。

**示例**：

输入：

    [
    [1, 200, 1],
    [2, 300, 2],
    [3, 400, 1],
    [4, 500, 2],
    [5, 600, 1]
    ]

输出：

    [
    [5, 600, 1]
    ]
解释：

在第二列（交易金额）中，600的深度是3，大于平均深度（2）的两倍，因此[5, 600, 1]可能是一个存在问题的交易记录。
ask for answer(press Enter twice to finish): 
**测试样例**：

**样例1**：

输入：

    [
    [1, 200, 1],
    [2, 300, 2],
    [3, 400, 1],
    [4, 500, 2],
    [5, 600, 1],
    [6, 700, 2]
    ]

输出：

    [
    [5, 600, 1],
    [6, 700, 2]
    ]

解释：

在第二列（交易金额）中，600和700的深度是3，大于平均深度（2）的两倍，因此[5, 600, 1]和[6, 700, 2]可能是存在问题的交易记录。

**样例2**：

输入：

    [
    [1, 100, 1],
    [2, 200, 2],
    [3, 300, 1],
    [4, 400, 2],
    [5, 500, 1],
    [6, 600, 2],
    [7, 700, 1],
    [8, 800, 2]
    ]

输出：

    [
    [6, 600, 2],
    [7, 700, 1],
    [8, 800, 2]
    ]

解释：

在第二列（交易金额）中，600、700和800的深度分别是3,4和4，大于平均深度（2）的两倍，因此[6, 600, 2]、[7, 700, 1]和[8, 800, 2]可能是存在问题的交易记录。

注意：在实现过程中，你需要自己生成更多的测试样例来验证你的算法的正确性和效率。
ask for answer(press Enter twice to finish): 
